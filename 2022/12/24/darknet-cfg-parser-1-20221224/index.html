<!doctypehtml><html class="theme-next muse use-motion" lang=zh-CN><meta charset=UTF-8><meta content=IE=edge http-equiv=X-UA-Compatible><meta content=width=device-width,initial-scale=1,maximum-scale=1 name=viewport><meta content=#222 name=theme-color><meta content=no-transform http-equiv=Cache-Control><meta content=no-siteapp http-equiv=Cache-Control><link href=/lib/fancybox/source/jquery.fancybox.css?v=2.1.5 rel=stylesheet><link href=/lib/font-awesome/css/font-awesome.min.css?v=4.6.2 rel=stylesheet><link href=/css/main.css?v=5.1.4 rel=stylesheet><link href=/images/apple-touch-icon-next.png?v=5.1.4 rel=apple-touch-icon sizes=180x180><link href=/images/favicon-32x32-next.png?v=5.1.4 rel=icon sizes=32x32 type=image/png><link href=/images/favicon-16x16-next.png?v=5.1.4 rel=icon sizes=16x16 type=image/png><link color=#222 href=/images/logo.svg?v=5.1.4 rel=mask-icon><meta content=深度学习系统,darknet源码, name=keywords><meta content=笔者在[1]一文中简单介绍了在darknet中常见的数据结构，本文继续上文的节奏，介绍如何从cfg文本文件中解析出整个网络的结构与参数。 name=description><meta content=article property=og:type><meta content="【darknet源码系列-2】 darknet源码中的cfg解析" property=og:title><meta content=https://fesianxu.github.io/2022/12/24/darknet-cfg-parser-1-20221224/index.html property=og:url><meta content=机器学习杂货铺总店 property=og:site_name><meta content=笔者在[1]一文中简单介绍了在darknet中常见的数据结构，本文继续上文的节奏，介绍如何从cfg文本文件中解析出整个网络的结构与参数。 property=og:description><meta content=zh_CN property=og:locale><meta content=https://fesianxu.github.io/2022/12/24/darknet-cfg-parser-1-20221224/qrcode.png property=og:image><meta content=https://fesianxu.github.io/2022/12/24/darknet-cfg-parser-1-20221224/imgs/section_linked_list.png property=og:image><meta content=2022-12-24T03:33:11.000Z property=article:published_time><meta content=2022-12-24T03:46:28.527Z property=article:modified_time><meta content=FesianXu property=article:author><meta content=深度学习系统 property=article:tag><meta content=darknet源码 property=article:tag><meta content=summary name=twitter:card><meta content=https://fesianxu.github.io/2022/12/24/darknet-cfg-parser-1-20221224/qrcode.png name=twitter:image><script id=hexo.configurations>var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };</script><link href=https://FesianXu.github.io/2022/12/24/darknet-cfg-parser-1-20221224/ rel=canonical><title>【darknet源码系列-2】 darknet源码中的cfg解析 | 机器学习杂货铺总店</title><meta content="Hexo 5.4.2" name=generator><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}</style><body itemscope itemtype=http://schema.org/WebPage lang=zh-CN><div class="container sidebar-position-left page-post-detail"><div class=headband></div><header class=header id=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-wrapper><div class=site-meta><div class=custom-logo-site-title><a class=brand href=/ rel=start> <span class=logo-line-before><i></i></span> <span class=site-title>机器学习杂货铺总店</span> <span class=logo-line-after><i></i></span> </a></div><p class=site-subtitle></div><div class=site-nav-toggle><button><span class=btn-bar></span> <span class=btn-bar></span> <span class=btn-bar></span></button></div></div><nav class=site-nav><ul class=menu id=menu><li class="menu-item menu-item-home"><a href=/ rel=section> <i class="menu-item-icon fa fa-fw fa-home"></i> <br> Home </a><li class="menu-item menu-item-about"><a href=/about/ rel=section> <i class="menu-item-icon fa fa-fw fa-user"></i> <br> About </a><li class="menu-item menu-item-tags"><a href=/tags/ rel=section> <i class="menu-item-icon fa fa-fw fa-tags"></i> <br> Tags </a><li class="menu-item menu-item-categories"><a href=/categories/ rel=section> <i class="menu-item-icon fa fa-fw fa-th"></i> <br> Categories </a><li class="menu-item menu-item-archives"><a href=/archives/ rel=section> <i class="menu-item-icon fa fa-fw fa-archive"></i> <br> Archives </a><li class="menu-item menu-item-search"><a class=popup-trigger href=javascript:;> <i class="menu-item-icon fa fa-search fa-fw"></i> <br> Search </a></ul><div class=site-search><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class=search-icon> <i class="fa fa-search"></i> </span><span class=popup-btn-close> <i class="fa fa-times-circle"></i> </span><div class=local-search-input-wrapper><input autocomplete=off id=local-search-input placeholder=Searching... spellcheck=false></div></div><div id=local-search-result></div></div></div></nav></div></header><main class=main id=main><div class=main-inner><div class=content-wrap><div class=content id=content><div class=posts-expand id=posts><article class="post post-type-normal" itemscope itemtype=http://schema.org/Article><div class=post-block><link href=https://FesianXu.github.io/2022/12/24/darknet-cfg-parser-1-20221224/ itemprop=mainEntityOfPage><span hidden itemprop=author itemscope itemtype=http://schema.org/Person> <meta itemprop=name> <meta itemprop=description> <meta content=/%5Bobject%20Object%5D itemprop=image> </span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization> <meta content=机器学习杂货铺总店 itemprop=name> </span><header class=post-header><h1 itemprop="name headline" class=post-title>【darknet源码系列-2】 darknet源码中的cfg解析</h1><div class=post-meta><span class=post-time> <span class=post-meta-item-icon> <i class="fa fa-calendar-o"></i> </span> <span class=post-meta-item-text>Posted on</span> <time itemprop="dateCreated datePublished" title="Post created" datetime=2022-12-24T11:33:11+08:00> 2022-12-24 </time> </span><span class=post-category> <span class=post-meta-divider>|</span> <span class=post-meta-item-icon> <i class="fa fa-folder-o"></i> </span> <span class=post-meta-item-text>In</span> <span itemprop=about itemscope itemtype=http://schema.org/Thing> <a href=/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F/ itemprop=url rel=index> <span itemprop=name>深度学习系统</span> </a> </span> </span><span class=post-meta-divider>|</span><span class=page-pv><i class="fa fa-file-o"></i> <span class=busuanzi-value id=busuanzi_value_page_pv></span> </span><div class=post-wordcount><span class=post-meta-item-icon> <i class="fa fa-file-word-o"></i> </span><span class=post-meta-item-text>Words count in article:</span><span title="Words count in article"> 3.5k 字 </span><span class=post-meta-divider>|</span><span class=post-meta-item-icon> <i class="fa fa-clock-o"></i> </span><span class=post-meta-item-text>Reading time ≈</span><span title="Reading time"> 14 分钟 </span></div></div></header><div class=post-body itemprop=articleBody><p>笔者在[1]一文中简单介绍了在<code>darknet</code>中常见的数据结构，本文继续上文的节奏，介绍如何从<code>cfg</code>文本文件中解析出整个网络的结构与参数。 <span id=more></span><div align=right>FesianXu 20201118 at UESTC</div><h1 id=前言>前言</h1><p>笔者在[1]一文中简单介绍了在<code>darknet</code>中常见的数据结构，本文继续上文的节奏，介绍如何从<code>cfg</code>文本文件中解析出整个网络的结构与参数。<strong>如有谬误请联系指出，本文遵守<a href=http://creativecommons.org/licenses/by-sa/4.0/ rel=noopener target=_blank>CC 4.0 BY-SA</a>版权协议，转载请联系作者并注明出处，谢谢</strong>。<p><span class="math inline"><mjx-container class=MathJax jax=SVG><svg style="vertical-align: -0.075ex;" viewbox="0 -683 833 716" focusable=false height=1.62ex role=img width=1.885ex xmlns=http://www.w3.org/2000/svg><g fill=currentColor stroke=currentColor stroke-width=0 transform=scale(1,-1)><g data-mml-node=math><g data-mml-node=mi><path d="M46 676Q46 679 51 683H781Q786 679 786 676Q786 674 617 326T444 -26Q439 -33 416 -33T388 -26Q385 -22 216 326T46 676ZM697 596Q697 597 445 597T193 596Q195 591 319 336T445 80L697 596Z" data-c=2207 /></g></g></g></svg></mjx-container></span> 联系方式：<p><strong>e-mail</strong>: FesianXu@gmail.com<p><strong>QQ</strong>: 973926198<p><strong>github</strong>: https://github.com/FesianXu<p><strong>知乎专栏</strong>: <a href=https://zhuanlan.zhihu.com/c_1265262560611299328 rel=noopener target=_blank>计算机视觉/计算机图形理论与应用</a><p><strong>微信公众号</strong>：<p><img src=/2022/12/24/darknet-cfg-parser-1-20221224/qrcode.png><hr><p><strong>注意：阅读本文之前，建议阅读[1]，以便对<code>darknet</code>的数据结构定义有所了解。</strong> 为了简便，本文暂时不考虑GPU下的运行，只考虑CPU运行的情况。<h1 id=初探>初探</h1><p>最主要的网络结构和参数解析函数在<code>/src/parser.c</code>里，该函数名为<code>network *parse_network_cfg</code>[2]，此函数完成了<code>cfg</code>文件的解析，并且通过解析得到的网络结构与参数初始化<code>network</code>结构体，以便于后续的网络计算。我们从该函数开始进行剖析，部分代码见coda 1.1，传入参数很简单，就是<code>cfg</code>文件的名字<code>char* filename</code>，而返回的就是解析并初始化后的<code>network*</code>。为了让读者回顾<code>darknet</code>的基本数据结构，我们展示Fig 1.1，该链表承载了作为解析过程中的主要数据负载作用。具体的函数分析见code 1.1的注释。<p><img src=/2022/12/24/darknet-cfg-parser-1-20221224/imgs/section_linked_list.png><div align=center><b> Fig 1.1 该双向链表承载了网络配置解析过程中的主要内容负载作用，此时注意到无论是front还是back，其终端都是NULL，这点需要去看函数list_insert[3]。 </b></div><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br><span class=line>40</span><br><span class=line>41</span><br><span class=line>42</span><br><span class=line>43</span><br><span class=line>44</span><br><span class=line>45</span><br><span class=line>46</span><br><span class=line>47</span><br><span class=line>48</span><br><span class=line>49</span><br><span class=line>50</span><br><span class=line>51</span><br><span class=line>52</span><br><span class=line>53</span><br><span class=line>54</span><br><span class=line>55</span><br><span class=line>56</span><br><span class=line>57</span><br><span class=line>58</span><br><span class=line>59</span><br><span class=line>60</span><br><span class=line>61</span><br><span class=line>62</span><br><span class=line>63</span><br><span class=line>64</span><br><span class=line>65</span><br><span class=line>66</span><br><span class=line>67</span><br><span class=line>68</span><br><span class=line>69</span><br><span class=line>70</span><br><span class=line>71</span><br><span class=line>72</span><br><span class=line>73</span><br><span class=line>74</span><br><span class=line>75</span><br><span class=line>76</span><br><span class=line>77</span><br><span class=line>78</span><br><span class=line>79</span><br><span class=line>80</span><br><span class=line>81</span><br><span class=line>82</span><br><span class=line>83</span><br><span class=line>84</span><br><span class=line>85</span><br><span class=line>86</span><br><span class=line>87</span><br><span class=line>88</span><br><span class=line>89</span><br><span class=line>90</span><br><span class=line>91</span><br><span class=line>92</span><br><span class=line>93</span><br><span class=line>94</span><br><span class=line>95</span><br><span class=line>96</span><br><span class=line>97</span><br></pre><td class=code><pre><span class=line>network *<span class="title function_">parse_network_cfg</span><span class=params>(<span class=type>char</span> *filename)</span></span><br><span class=line>{</span><br><span class=line>    <span class=built_in>list</span> *sections = read_cfg(filename); <span class=comment>// 解析cfg配置文件，返回配置链表，如Fig 1.1所示</span></span><br><span class=line>    node *n = sections->front; <span class=comment>// 获取sections的首节点，一般是[network]或者[net]类型的section</span></span><br><span class=line>    <span class=keyword>if</span>(!n) error(<span class=string>"Config file has no sections"</span>); <span class=comment>// 判断是否存在section</span></span><br><span class=line>    network *net = make_network(sections->size - <span class=number>1</span>); <span class=comment>//构建network,其中的sections->size是包括了[net]之后的长度，因此要减去1，一共有sections->size-1层。</span></span><br><span class=line>    net->gpu_index = gpu_index;</span><br><span class=line>    size_params params; <span class=comment>// 该数据结构承担了初始化网络结构，参数的重任，该结构体的定义如code 1.2所示。</span></span><br><span class=line></span><br><span class=line>    section *s = (section *)n->val;</span><br><span class=line>    <span class=comment>// 取得第一个section节点的指针，因为第一个section一般是一些全局的配置，具体见[1]。</span></span><br><span class=line>    <span class=built_in>list</span> *options = s->options; <span class=comment>// 第一个section内容负载中的双向链表</span></span><br><span class=line>    <span class=comment>// 第一个section类型必须是[net]或者[network]</span></span><br><span class=line>    <span class=keyword>if</span>(!is_network(s)) error(<span class=string>"First section must be [net] or [network]"</span>);</span><br><span class=line>    <span class=comment>// 如果没啥问题，就开始解析网络的全局配置，也即是[net]中的内容，将解析出的内容赋值到net数据结构中</span></span><br><span class=line>    parse_net_options(options, net); </span><br><span class=line></span><br><span class=line>    params.h = net->h;</span><br><span class=line>    params.w = net->w;</span><br><span class=line>    params.c = net->c;</span><br><span class=line>    params.inputs = net->inputs;</span><br><span class=line>    params.batch = net->batch;</span><br><span class=line>    params.time_steps = net->time_steps;</span><br><span class=line>    params.net = net;</span><br><span class=line>    <span class=comment>// 这一段都是在对对应的值进行赋值，没太多可说的</span></span><br><span class=line></span><br><span class=line>    <span class=type>size_t</span> workspace_size = <span class=number>0</span>;</span><br><span class=line>    <span class=comment>// workspace_size 指明了所有层（layer）中最大的内存需求，从而提前开辟出整块内存以便后续计算，同一时间内，GPU或者CPU只有一个层在计算，因此只需要满足最大内存需求即可。</span></span><br><span class=line>    n = n->next; <span class=comment>// 我们已经把[net]结构体解析完啦，现在我们考虑之后的层，一般就是实际的神经网络层了。</span></span><br><span class=line>    <span class=type>int</span> count = <span class=number>0</span>;</span><br><span class=line>    free_section(s); </span><br><span class=line>    <span class=built_in>fprintf</span>(<span class=built_in>stderr</span>, <span class=string>"layer     filters    size              input                output\n"</span>);</span><br><span class=line>    <span class=keyword>while</span>(n){  <span class=comment>// 当 NULL == n 的时候退出解析</span></span><br><span class=line>        params.index = count; <span class=comment>// 每一层的计数器，从0开始</span></span><br><span class=line>        <span class=built_in>fprintf</span>(<span class=built_in>stderr</span>, <span class=string>"%5d "</span>, count);</span><br><span class=line>        s = (section *)n->val; <span class=comment>// 每一层的实际负载，也即是section本体</span></span><br><span class=line>        options = s->options; <span class=comment>// 实际section的双向链表，其中的元素</span></span><br><span class=line>        layer l = {<span class=number>0</span>}; <span class=comment>// 解析出的section将初始化到layer中，此处先定义layer。</span></span><br><span class=line>        LAYER_TYPE lt = string_to_layer_type(s->type); <span class=comment>// 将字符串格式的层名，比如[convolutional]等解析为枚举类型的数据</span></span><br><span class=line>        </span><br><span class=line>        <span class=comment>// 针对不同类型的层lt，有着不同的解析函数，格式为 parse_xxxx(options, params)，我们后续以卷积层为例子，其他层也是类似的。</span></span><br><span class=line>        <span class=keyword>if</span>(lt == CONVOLUTIONAL){</span><br><span class=line>            l = parse_convolutional(options, params);</span><br><span class=line>        }<span class=keyword>else</span> <span class=keyword>if</span>(lt == DECONVOLUTIONAL){</span><br><span class=line>            l = parse_deconvolutional(options, params);</span><br><span class=line>        }</span><br><span class=line>        .... </span><br><span class=line>        <span class=comment>// 为了简便，这里省略了很多相似的parse解析函数，分别解析不同的层</span></span><br><span class=line>        <span class=keyword>else</span> <span class=keyword>if</span>(lt == DROPOUT){</span><br><span class=line>            l = parse_dropout(options, params);</span><br><span class=line>            l.output = net->layers[count<span class=number>-1</span>].output;</span><br><span class=line>            l.delta = net->layers[count<span class=number>-1</span>].delta;</span><br><span class=line>        }<span class=keyword>else</span>{</span><br><span class=line>            <span class=built_in>fprintf</span>(<span class=built_in>stderr</span>, <span class=string>"Type not recognized: %s\n"</span>, s->type);</span><br><span class=line>        }</span><br><span class=line>        </span><br><span class=line>        l.clip = net->clip;</span><br><span class=line>        l.truth = option_find_int_quiet(options, <span class=string>"truth"</span>, <span class=number>0</span>);</span><br><span class=line>        ....</span><br><span class=line>        <span class=comment>// 这里省略了类似的参数解析过程</span></span><br><span class=line>        l.learning_rate_scale = option_find_float_quiet(options, <span class=string>"learning_rate"</span>, <span class=number>1</span>);</span><br><span class=line>        l.smooth = option_find_float_quiet(options, <span class=string>"smooth"</span>, <span class=number>0</span>);</span><br><span class=line>        <span class=comment>// 针对每个特定层，还可以指定其特定的学习率learning_rate，是否停止梯度stopbackward,平滑smooth,保存参数与否dontsave，加载参数与否dontload,等细节参数，这些参数将会在该层覆盖全局[net]的设置。这里的代码在解析这些参数。</span></span><br><span class=line>        </span><br><span class=line>        option_unused(options); <span class=comment>// 将没有使用到的参数打印（因为有可能cfg文件写错了，某些层不需要某些参数，但是又多写了，这里需要提示出来）</span></span><br><span class=line>        net->layers[count] = l; <span class=comment>// 将解析得到的layer赋值到network中。</span></span><br><span class=line>        <span class=keyword>if</span> (l.workspace_size > workspace_size) workspace_size = l.workspace_size;</span><br><span class=line>        <span class=comment>// 每个特定层，需要的内存空间是不一样的，这个在定义某个层的时候是需要预先定义（计算）出来的，通过这个代码纪录整个网络需要的最大内存空间。</span></span><br><span class=line>        free_section(s); <span class=comment>// 释放解析临时内存</span></span><br><span class=line>        n = n->next; <span class=comment>// 走，哥们我们去下一个section</span></span><br><span class=line>        ++count;</span><br><span class=line>        <span class=keyword>if</span>(n){</span><br><span class=line>            params.h = l.out_h;</span><br><span class=line>            params.w = l.out_w;</span><br><span class=line>            params.c = l.out_c;</span><br><span class=line>            params.inputs = l.outputs;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    </span><br><span class=line>    free_list(sections);</span><br><span class=line>    layer out = get_network_output_layer(net); <span class=comment>// 取得输出层的句柄</span></span><br><span class=line>    net->outputs = out.outputs;</span><br><span class=line>    net->truths = out.outputs;</span><br><span class=line>    <span class=keyword>if</span>(net->layers[net->n<span class=number>-1</span>].truths) net->truths = net->layers[net->n<span class=number>-1</span>].truths;</span><br><span class=line>    net->output = out.output;</span><br><span class=line>    <span class=comment>// 网络的输出就是输出层的最终输出</span></span><br><span class=line>    net->input = <span class=built_in>calloc</span>(net->inputs*net->batch, <span class=keyword>sizeof</span>(<span class=type>float</span>));</span><br><span class=line>    <span class=comment>// 给网络输入分配空间,大小取决于每个样本的维度net->inputs和批次大小net->batch</span></span><br><span class=line>    net->truth = <span class=built_in>calloc</span>(net->truths*net->batch, <span class=keyword>sizeof</span>(<span class=type>float</span>));</span><br><span class=line>    <span class=comment>// ground truths 的内存分配</span></span><br><span class=line>    <span class=keyword>if</span>(workspace_size){</span><br><span class=line>        <span class=comment>//printf("%ld\n", workspace_size);</span></span><br><span class=line>    	net->workspace = <span class=built_in>calloc</span>(<span class=number>1</span>, workspace_size);</span><br><span class=line>    }</span><br><span class=line>    <span class=comment>// 正如之前说的，在任意时刻 GPU或者CPU中只有一个层在运行，因此只需要预先分配所有层的最大内存需求即可了。</span></span><br><span class=line>    <span class=keyword>return</span> net;</span><br><span class=line>}</span><br></pre></table></figure><div align=center><b> code 1.1 parse_network_cfg的函数定义，注意到为了显示简便，省略了许多重复类似的语句，读者可以查阅源代码或者根据上下文得知含义。 </b></div><p>整个<code>parse_network_cfg</code>的全景就如code 1.1所示，其中涉及到了一个临时的中间数据结构<code>size_params</code>，我们之前没有谈到，该结构定义如code 1.2所示。我们如果认真分析整个过程，发现其实这个函数分为两大阶段：解析，网络初始化。因此后续的章节也按照这两个部分分别剖析。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre><td class=code><pre><span class=line><span class=keyword>typedef</span> <span class=class><span class=keyword>struct</span> <span class=title>size_params</span>{</span></span><br><span class=line>    <span class=type>int</span> batch;</span><br><span class=line>    <span class=type>int</span> inputs;</span><br><span class=line>    <span class=type>int</span> h;</span><br><span class=line>    <span class=type>int</span> w;</span><br><span class=line>    <span class=type>int</span> c;</span><br><span class=line>    <span class=type>int</span> index;</span><br><span class=line>    <span class=type>int</span> time_steps;</span><br><span class=line>    network *net;</span><br><span class=line>} size_params;</span><br></pre></table></figure><div align=center><b> code 1.2 该数据结构是临时数据结构，用以储存解析-定义网络过程中的数据。 </b></div><h1 id=cfg解析>cfg解析</h1><p>与<code>cfg</code>解析有关的函数有很多，主要的是<ol type=1><li><code>list* read_cfg(char* filename)</code>：用于解析主要的section列表等，见Fig 1.1。<li><code>void parse_net_options(list *options, network *net)</code>：该函数用于解析<code>[net]</code>中的每个键值对。<li><code>layer parse_xxxxx(list *options, size_params params)</code>：该类型函数用于解析每个特定的神经网络层的参数，比如<code>convolutional_layer parse_convolutional(list *options, size_params params)</code>，本文会以这个函数作为例子进行剖析。</ol><h2 id=read_cfg>read_cfg</h2><p><code>read_cfg</code>输入<code>cfg</code>文件名，输出网络配置解析列表，如Fig 1.1。<code>read_cfg</code>的具体注释见code 2.1。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br></pre><td class=code><pre><span class=line><span class=built_in>list</span> *<span class="title function_">read_cfg</span><span class=params>(<span class=type>char</span> *filename)</span></span><br><span class=line>{</span><br><span class=line>    FILE *file = fopen(filename, <span class=string>"r"</span>); <span class=comment>// 读文件</span></span><br><span class=line>    <span class=keyword>if</span>(file == <span class=number>0</span>) file_error(filename); <span class=comment>// 判空</span></span><br><span class=line>    <span class=type>char</span> *line; <span class=comment>// 每一行的指针，记得用完要释放内存</span></span><br><span class=line>    <span class=type>int</span> nu = <span class=number>0</span>; <span class=comment>// 行数计数器</span></span><br><span class=line>    <span class=built_in>list</span> *options = make_list(); <span class=comment>// 新建一个双向链表，这个链表是主链，用于储存section，该结构定义见[1]</span></span><br><span class=line>    section *current = <span class=number>0</span>; <span class=comment>// 每一个section的指针</span></span><br><span class=line>    <span class=keyword>while</span>((line=fgetl(file)) != <span class=number>0</span>){ <span class=comment>// 读取每一行的数据，如果为0表示读完了</span></span><br><span class=line>        ++ nu; <span class=comment>// 行计数器加一</span></span><br><span class=line>        strip(line); <span class=comment>// 去除头尾的空格</span></span><br><span class=line>        <span class=keyword>switch</span>(line[<span class=number>0</span>]){ </span><br><span class=line>         	<span class=comment>// 如果每一行的第一个字符是'['，那么确定是标志了新的section的开始。</span></span><br><span class=line>            <span class=keyword>case</span> <span class=string>'['</span>:</span><br><span class=line>                <span class=comment>// 因此需要对新的section进行内存分配</span></span><br><span class=line>                current = <span class=built_in>malloc</span>(<span class=keyword>sizeof</span>(section));</span><br><span class=line>                list_insert(options, current); <span class=comment>// 将新的section插入options链表</span></span><br><span class=line>                current->options = make_list(); <span class=comment>// 新建链表，该链表是用于储存键值对的。</span></span><br><span class=line>                current->type = line; <span class=comment>// [xxxx] 表示了该层的类型，将其存入type，比如[convolutional]</span></span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>case</span> <span class=string>'\0'</span>: <span class=comment>// 忽略新行</span></span><br><span class=line>            <span class=keyword>case</span> <span class=string>'#'</span>: <span class=comment>// 忽略注释</span></span><br><span class=line>            <span class=keyword>case</span> <span class=string>';'</span>:</span><br><span class=line>                <span class=comment>// 这些无关的标志位，可以开始释放line内存了</span></span><br><span class=line>                <span class=built_in>free</span>(line);</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>            <span class=keyword>default</span>:</span><br><span class=line>                <span class=comment>// 如果都不是，那么意味着是开始section的真实内容负载了，开始解析，并且将解析出的键值对放置到section中。</span></span><br><span class=line>                <span class=keyword>if</span>(!read_option(line, current->options)){</span><br><span class=line>                    <span class=built_in>fprintf</span>(<span class=built_in>stderr</span>, <span class=string>"Config file error line %d, could parse: %s\n"</span>, nu, line);</span><br><span class=line>                    <span class=built_in>free</span>(line);</span><br><span class=line>                }</span><br><span class=line>                <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    fclose(file); <span class=comment>// 关闭文件</span></span><br><span class=line>    <span class=keyword>return</span> options;</span><br><span class=line>}</span><br></pre></table></figure><div align=center><b> code 2.1 read_cfg函数注释，其是解析cfg文件的主要函数。 </b></div><p>该函数中有一个最为关键的调用函数，就是<code>int read_option(char *s, list *options)</code>，该函数用于解析每一个section内的键值对（注意到此时仍然只是字符串），具体定义见code 2.2的详细注释。通过<code>read_cfg()</code>函数，我们将配置解析到了链表中，之后就可以关闭<code>cfg</code>文件，直接读取链表进行网络初始化即可，这样不仅提高了效率，而且减少了因为读取网络过程中，意外修改配置文件导致错误出现的可能性。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre><td class=code><pre><span class=line><span class=type>int</span> <span class="title function_">read_option</span><span class=params>(<span class=type>char</span> *s, <span class=built_in>list</span> *options)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>size_t</span> i;</span><br><span class=line>    <span class=type>size_t</span> len = <span class=built_in>strlen</span>(s);</span><br><span class=line>    <span class=type>char</span> *val = <span class=number>0</span>; <span class=comment>// 键值对中的数值</span></span><br><span class=line>    <span class=keyword>for</span>(i = <span class=number>0</span>; i < len; ++i){ </span><br><span class=line>        <span class=keyword>if</span>(s[i] == <span class=string>'='</span>){ <span class=comment>// 以'='作为截断的标志，中间不能出现空格</span></span><br><span class=line>            s[i] = <span class=string>'\0'</span>; <span class=comment>// 截断key-val，将'='替换成截断位，也即是'\0'。</span></span><br><span class=line>            val = s+i+<span class=number>1</span>; <span class=comment>// 将val指向值的地址位置，因为已经做过了截断，因此需要+1</span></span><br><span class=line>            <span class=keyword>break</span>;</span><br><span class=line>        }</span><br><span class=line>    }</span><br><span class=line>    <span class=keyword>if</span>(i == len<span class=number>-1</span>) <span class=keyword>return</span> <span class=number>0</span>;</span><br><span class=line>    <span class=type>char</span> *key = s; <span class=comment>// 显然之前的一段是键值，因为加了'\0'作为截断，因此现在key和val都是提取出来了</span></span><br><span class=line>    option_insert(options, key, val); <span class=comment>// 添加到section链表中,见code 2.3</span></span><br><span class=line>    <span class=keyword>return</span> <span class=number>1</span>;</span><br><span class=line>}</span><br></pre></table></figure><div align=center><b> code 2.2 read_option用以解析键值对，并且将其添加到指定的section链表中。 </b></div><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre><td class=code><pre><span class=line><span class=type>void</span> <span class="title function_">option_insert</span><span class=params>(<span class=built_in>list</span> *l, <span class=type>char</span> *key, <span class=type>char</span> *val)</span></span><br><span class=line>{</span><br><span class=line>    kvp *p = <span class=built_in>malloc</span>(<span class=keyword>sizeof</span>(kvp));</span><br><span class=line>    p->key = key;</span><br><span class=line>    p->val = val;</span><br><span class=line>    p->used = <span class=number>0</span>;</span><br><span class=line>    list_insert(l, p);</span><br><span class=line>}</span><br></pre></table></figure><div align=center><b> code 2.3 option_insert将键值对添加到section链表中。 </b></div><h2 id=parse_net_options>parse_net_options</h2><p>这个函数负责解析<code>[net]</code>部分的参数，这类型的参数和一般的section不同，其是全局的网络配置，因此独立成了一个函数。其没有太难理解的东西，基本上就是调用一系列字符串解析函数，这系列的函数会去读取之前解析到的参数链表，将其中section中的键值对解析出特定的数据类型（比如<code>int</code>,<code>float</code>），因此对应有很多类似的函数，比如：<ol type=1><li><code>int option_find_int(list *l, char *key, int def)</code><li><code>float option_find_float(list *l, char *key, float def)</code><li><code>char *option_find_str(list *l, char *key, char *def)</code></ol><figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre><td class=code><pre><span class=line><span class=type>void</span> <span class="title function_">parse_net_options</span><span class=params>(<span class=built_in>list</span> *options, network *net)</span></span><br><span class=line>{</span><br><span class=line>    net->batch = option_find_int(options, <span class=string>"batch"</span>,<span class=number>1</span>);</span><br><span class=line>    net->learning_rate = option_find_float(options, <span class=string>"learning_rate"</span>, <span class=number>.001</span>);</span><br><span class=line>    net->momentum = option_find_float(options, <span class=string>"momentum"</span>, <span class=number>.9</span>);</span><br><span class=line>    net->decay = option_find_float(options, <span class=string>"decay"</span>, <span class=number>.0001</span>);</span><br><span class=line>    <span class=type>int</span> subdivs = option_find_int(options, <span class=string>"subdivisions"</span>,<span class=number>1</span>);</span><br><span class=line>    net->time_steps = option_find_int_quiet(options, <span class=string>"time_steps"</span>,<span class=number>1</span>);</span><br><span class=line>    net->notruth = option_find_int_quiet(options, <span class=string>"notruth"</span>,<span class=number>0</span>);</span><br><span class=line>    net->batch /= subdivs;</span><br><span class=line>    net->batch *= net->time_steps;</span><br><span class=line>    net->subdivisions = subdivs;</span><br><span class=line>    net->random = option_find_int_quiet(options, <span class=string>"random"</span>, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>    net->adam = option_find_int_quiet(options, <span class=string>"adam"</span>, <span class=number>0</span>);</span><br><span class=line>    <span class=keyword>if</span>(net->adam){</span><br><span class=line>        net->B1 = option_find_float(options, <span class=string>"B1"</span>, <span class=number>.9</span>);</span><br><span class=line>        net->B2 = option_find_float(options, <span class=string>"B2"</span>, <span class=number>.999</span>);</span><br><span class=line>        net->eps = option_find_float(options, <span class=string>"eps"</span>, <span class=number>.0000001</span>);</span><br><span class=line>    }</span><br><span class=line>    ... </span><br><span class=line>    <span class=comment>// 省略了类似参数的解析过程</span></span><br><span class=line>}</span><br></pre></table></figure><div align=center><b> code 2.4 parse_net_options将`[net]`中的全局参数进行解析，并且放置到`net`数据结构中。 </b></div><h2 id=parse_xxx>parse_xxx</h2><p>该类型的函数用于解析某个特定的层，比如<code>convolutional</code>卷积层，<code>deconvolutional</code>转置卷积层，<code>activation</code>激活层等等，其中的<code>xxx</code>表明了层的种类，如果想要定制某个新的层，需要进行类似的注册（也即是需要书写自己的<code>parse_new_layer()</code>函数等）。本文以<code>parse_convolutional()</code>作为例子进行讲解。从code 2.5中可以发现，其中最主要的函数是<code>make_convolutional_layer()</code>，用以通过解析得到的卷积层参数去构造卷积层。<figure class="highlight c"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre><td class=code><pre><span class=line>convolutional_layer <span class="title function_">parse_convolutional</span><span class=params>(<span class=built_in>list</span> *options, size_params params)</span></span><br><span class=line>{</span><br><span class=line>    <span class=type>int</span> n = option_find_int(options, <span class=string>"filters"</span>,<span class=number>1</span>);</span><br><span class=line>    <span class=type>int</span> size = option_find_int(options, <span class=string>"size"</span>,<span class=number>1</span>);</span><br><span class=line>    <span class=type>int</span> stride = option_find_int(options, <span class=string>"stride"</span>,<span class=number>1</span>);</span><br><span class=line>    <span class=type>int</span> pad = option_find_int_quiet(options, <span class=string>"pad"</span>,<span class=number>0</span>);</span><br><span class=line>    <span class=type>int</span> padding = option_find_int_quiet(options, <span class=string>"padding"</span>,<span class=number>0</span>);</span><br><span class=line>    <span class=type>int</span> groups = option_find_int_quiet(options, <span class=string>"groups"</span>, <span class=number>1</span>);</span><br><span class=line>    <span class=comment>// 解析和卷积层相关的参数，比如滤波器通道数，大小，步进，填充等</span></span><br><span class=line>    <span class=keyword>if</span>(pad) padding = size/<span class=number>2</span>;</span><br><span class=line></span><br><span class=line>    <span class=type>char</span> *activation_s = option_find_str(options, <span class=string>"activation"</span>, <span class=string>"logistic"</span>); </span><br><span class=line>    ACTIVATION activation = get_activation(activation_s); <span class=comment>// 得到指定的激活层，枚举类型</span></span><br><span class=line></span><br><span class=line>    <span class=type>int</span> batch,h,w,c;</span><br><span class=line>    h = params.h;</span><br><span class=line>    w = params.w;</span><br><span class=line>    c = params.c; <span class=comment>// 数据集图片的基本参数，包括长宽，通道数</span></span><br><span class=line>    batch = params.batch; <span class=comment>// 批次大小</span></span><br><span class=line>    <span class=keyword>if</span>(!(h && w && c)) error(<span class=string>"Layer before convolutional layer must output image."</span>);</span><br><span class=line>    <span class=type>int</span> batch_normalize = option_find_int_quiet(options, <span class=string>"batch_normalize"</span>, <span class=number>0</span>);</span><br><span class=line>    <span class=type>int</span> binary = option_find_int_quiet(options, <span class=string>"binary"</span>, <span class=number>0</span>);</span><br><span class=line>    <span class=type>int</span> xnor = option_find_int_quiet(options, <span class=string>"xnor"</span>, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>    convolutional_layer layer = make_convolutional_layer(batch,h,w,c,n,groups,size,stride,padding,activation, batch_normalize, binary, xnor, params.net->adam); <span class=comment>// 构造卷积层</span></span><br><span class=line>    layer.flipped = option_find_int_quiet(options, <span class=string>"flipped"</span>, <span class=number>0</span>);</span><br><span class=line>    layer.dot = option_find_float_quiet(options, <span class=string>"dot"</span>, <span class=number>0</span>);</span><br><span class=line></span><br><span class=line>    <span class=keyword>return</span> layer;</span><br><span class=line>}</span><br></pre></table></figure><div align=center><b> code 2.5 parse_convolutional的函数注解，其中最主要的函数是make_convolutional_layer，用以通过解析得到的卷积层参数去构造卷积层。 </b></div><p>每个特定的神经网络层都有其特定的<code>make_xxx_layer()</code>函数，用以将解析得到的参数构造出特定的层。这个内容我们留到下一篇博文进行剖析，至此我们已经完全将<code>cfg</code>文件进行了解析。<h1 id=该系列其他文章>该系列其他文章</h1><ol type=1><li><a href=https://fesian.blog.csdn.net/article/details/109779812 rel=noopener target=_blank>[darknet源码系列-1] darknet源码中的常见数据结构</a></ol><h1 id=reference>Reference</h1><p>[1]. <a href=https://fesian.blog.csdn.net/article/details/109779812 rel=noopener target=_blank>[darknet源码系列-1] darknet源码中的常见数据结构</a><p>[2]. https://github.com/pjreddie/darknet/blob/4a03d405982aa1e1e911eac42b0ffce29cc8c8ef/src/parser.c#L742<p>[3]. https://github.com/pjreddie/darknet/blob/4a03d405982aa1e1e911eac42b0ffce29cc8c8ef/src/list.c#L40</div><div><ul class=post-copyright><li class=post-copyright-author><strong>Post author:</strong> FesianXu<li class=post-copyright-link><strong>Post link:</strong> <a title="【darknet源码系列-2】 darknet源码中的cfg解析" href=https://fesianxu.github.io/2022/12/24/darknet-cfg-parser-1-20221224/>https://fesianxu.github.io/2022/12/24/darknet-cfg-parser-1-20221224/</a><li class=post-copyright-license><strong>Copyright Notice: </strong> All articles in this blog are licensed under <a rel="external nofollow" href=https://creativecommons.org/licenses/by-nc-sa/3.0/ target=_blank>CC BY-NC-SA 3.0</a> unless stating additionally.</ul></div><footer class=post-footer><div class=post-tags><a href=/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%B3%BB%E7%BB%9F/ rel=tag># 深度学习系统</a><a href=/tags/darknet%E6%BA%90%E7%A0%81/ rel=tag># darknet源码</a></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/2022/12/24/retrieve-system-metric-20221224/ rel=next title=搜索系统中的一些指标> <i class="fa fa-chevron-left"></i> 搜索系统中的一些指标 </a></div><span class=post-nav-divider></span><div class="post-nav-prev post-nav-item"><a title="【darknet源码系列-3】 在darknet中，如何根据解析出来的配置进行网络层构建" href=/2022/12/24/darknet-network-build-2-20221224/ rel=prev> 【darknet源码系列-3】 在darknet中，如何根据解析出来的配置进行网络层构建 <i class="fa fa-chevron-right"></i> </a></div></div></footer></div></article><div class=post-spread></div></div></div></div><div class=sidebar-toggle><div class=sidebar-toggle-line-wrap><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside class=sidebar id=sidebar><div class=sidebar-inner><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target=post-toc-wrap>Table of Contents<li class=sidebar-nav-overview data-target=site-overview-wrap>Overview</ul><section class="site-overview-wrap sidebar-panel"><div class=site-overview><div class="site-author motion-element" itemprop=author itemscope itemtype=http://schema.org/Person><img alt class=site-author-image itemprop=image src=/%5Bobject%20Object%5D><p class=site-author-name itemprop=name><p class="site-description motion-element" itemprop=description></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href=/archives/%7C%7C%20archive> <span class=site-state-item-count>102</span> <span class=site-state-item-name>posts</span> </a></div><div class="site-state-item site-state-categories"><a href=/categories/index.html> <span class=site-state-item-count>31</span> <span class=site-state-item-name>categories</span> </a></div><div class="site-state-item site-state-tags"><a href=/tags/index.html> <span class=site-state-item-count>178</span> <span class=site-state-item-name>tags</span> </a></div></nav><div class="links-of-author motion-element"><span class=links-of-author-item> <a href=https://github.com/FesianXu target=_blank title=GitHub> <i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class=links-of-author-item> <a href=mailto:FesianXu@gmail.com target=_blank title=E-Mail> <i class="fa fa-fw fa-envelope"></i>E-Mail</a> </span><span class=links-of-author-item> <a href=https://stackoverflow.com/users/7348519/fesianxu target=_blank title=StackOverflow> <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a> </span></div></div></section><!--noindex--><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class=post-toc><div class=post-toc-content><ol class=nav><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%89%8D%E8%A8%80><span class=nav-number>1.</span> <span class=nav-text>前言</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#%E5%88%9D%E6%8E%A2><span class=nav-number>2.</span> <span class=nav-text>初探</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#cfg%E8%A7%A3%E6%9E%90><span class=nav-number>3.</span> <span class=nav-text>cfg解析</span></a><ol class=nav-child><li class="nav-item nav-level-2"><a class=nav-link href=#read_cfg><span class=nav-number>3.1.</span> <span class=nav-text>read_cfg</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#parse_net_options><span class=nav-number>3.2.</span> <span class=nav-text>parse_net_options</span></a><li class="nav-item nav-level-2"><a class=nav-link href=#parse_xxx><span class=nav-number>3.3.</span> <span class=nav-text>parse_xxx</span></a></ol><li class="nav-item nav-level-1"><a class=nav-link href=#%E8%AF%A5%E7%B3%BB%E5%88%97%E5%85%B6%E4%BB%96%E6%96%87%E7%AB%A0><span class=nav-number>4.</span> <span class=nav-text>该系列其他文章</span></a><li class="nav-item nav-level-1"><a class=nav-link href=#reference><span class=nav-number>5.</span> <span class=nav-text>Reference</span></a></ol></div></div></section><!--/noindex--></div></aside></div></main><footer class=footer id=footer><div class=footer-inner><div class=copyright>© <span itemprop=copyrightYear>2024</span><span class=with-love> <i class="fa fa-user"></i> </span><span class=author itemprop=copyrightHolder>FesianXu</span></div><div class=“theme-info”><div class=“powered-by”></div><span class=“post-count”> 该站点文章共351.7k字，欢迎光临~ </span></div><script async src=https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><div class=busuanzi-count><script async src=https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js></script><span class=site-uv> <i class="fa fa-user"></i> <span class=busuanzi-value id=busuanzi_value_site_uv></span> </span><span class=site-pv> <i class="fa fa-eye"></i> <span class=busuanzi-value id=busuanzi_value_site_pv></span> </span></div></div></footer><div class=back-to-top><i class="fa fa-arrow-up"></i></div></div><script>if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }</script><script src=/lib/jquery/index.js></script><script src=/lib/fastclick/lib/fastclick.min.js></script><script src=/lib/jquery_lazyload/jquery.lazyload.js></script><script src=/lib/velocity/velocity.min.js></script><script src=/lib/velocity/velocity.ui.min.js></script><script src=/lib/fancybox/source/jquery.fancybox.pack.js></script><script src=/js/src/utils.js></script><script src=/js/src/motion.js></script><script src=/js/src/scrollspy.js></script><script src=/js/src/post-details.js></script><script src=/js/src/bootstrap.js></script><script>// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><script src=/live2dw/lib/L2Dwidget.min.js></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script>